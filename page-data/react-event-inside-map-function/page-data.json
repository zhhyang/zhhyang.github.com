{"componentChunkName":"component---src-templates-blog-post-js","path":"/react-event-inside-map-function/","result":{"data":{"site":{"siteMetadata":{"title":"Freeman 的博客"}},"markdownRemark":{"id":"b2b08d45-dca6-56ce-ad7a-1fd571960a79","excerpt":"在使用React 渲染列表的时候，我们一般的操作如下 如果我们给渲染的item添加事件，代码如下： 或者 我们分析一下： 第一种方式，在onClick的时候使用匿名函数，每次点击都产生一个新的匿名函数，如果array有10000个数据，那么将产生10000个匿名函数。\n第二种方式，bind…","html":"<p>在使用React 渲染列表的时候，我们一般的操作如下</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">render(){\n  const {array} = this.props\n  return (\n    &lt;div&gt;\n      {\n        array.map(item =&gt; \n            &lt;p key={item.id}&gt;{item.name}&lt;/p&gt;\n        )\n      }\n    &lt;/div&gt; \n  )\n}</code></pre></div>\n<p>如果我们给渲染的item添加事件，代码如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">constructor(props){\n  super(props)\n  this.onClick = this.onClick.bind(this)\n}\n\nonClick(value){\n  console.log(value)\n}\n\n\nrender(){\n  const {array} = this.props\n  return (\n    &lt;div&gt;\n      {\n        array.map(item =&gt; \n            &lt;p key={item.id} onClick={() =&gt; this.onClick(item.id)}&gt;{item.name}&lt;/p&gt;\n        )\n      }\n    &lt;/div&gt; \n  )\n}</code></pre></div>\n<p>或者</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">constructor(props){\n  super(props)\n}\n\nonClick(value){\n  console.log(value)\n}\n\n\nrender(){\n  const {array} = this.props\n  return (\n    &lt;div&gt;\n      {\n        array.map(item =&gt; \n            &lt;p key={item.id} onClick={this.onClick.bind(this,item.id)}&gt;{item.name}&lt;/p&gt;\n        )\n      }\n    &lt;/div&gt; \n  )\n}</code></pre></div>\n<p>我们分析一下：</p>\n<p>第一种方式，在onClick的时候使用匿名函数，每次点击都产生一个新的匿名函数，如果array有10000个数据，那么将产生10000个匿名函数。\n第二种方式，bind() 会创建一个绑定了作用域的函数实例。于是，内存中存储了几乎一样的函数的一万个拷贝，这是一种巨大的浪费</p>\n<p>所以我们在最第一种方式的基础上做一下改造</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">constructor(props){\n  super(props)\n  this.onClick = this.onClick.bind(this)\n}\n\nonClick(event){\n  const {id} = event.target\n  console.log(id)\n}\n\n\nrender(){\n  const {array} = this.props\n  return (\n    &lt;div&gt;\n      {\n        array.map(item =&gt; \n            &lt;p key={item.id} id={item.id} onClick={this.onClick}&gt;{item.name}&lt;/p&gt;\n        )\n      }\n    &lt;/div&gt; \n  )\n}</code></pre></div>\n<p>我们在构造方法中bind一次，每一个循环的p 都维护onClick的点击处理事件 this.onClick 根据每一个p上的props id 传递id，这样只产生了一个onClick函数</p>\n<p>我们也可以利用ES2017 中的Class properties </p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">onClick = (event) =&gt; {\n  const {id} = event.target\n  console.log(id)\n}\n\n\nrender(){\n  const {array} = this.props\n  return (\n    &lt;div&gt;\n      {\n        array.map(item =&gt; \n            &lt;p key={item.id} id={item.id} onClick={this.onClick}&gt;{item.name}&lt;/p&gt;\n        )\n      }\n    &lt;/div&gt; \n  )\n}</code></pre></div>","frontmatter":{"title":"React event inside map function","date":"September 04, 2017","description":null}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/react-event-inside-map-function/","previous":{"fields":{"slug":"/create-react-component/"},"frontmatter":{"title":"React之组件的三种创建方式"}},"next":null}}}