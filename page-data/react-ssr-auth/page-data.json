{"componentChunkName":"component---src-templates-blog-post-js","path":"/react-ssr-auth/","result":{"data":{"site":{"siteMetadata":{"title":"Freeman 的博客"}},"markdownRemark":{"id":"6253dbdc-2162-5f1b-ae91-7a3946e94169","excerpt":"在使用React构建应用的过程中，如何判断当前的登录状态，是每个应用都要遇到的问题，而Client端渲染，常用的JWT模式，对于token的保存，一般都是保存在localStorage中，而在服务端渲染中，是没有localStorage的定义的 既然我们无法从localStorage…","html":"<p>在使用React构建应用的过程中，如何判断当前的登录状态，是每个应用都要遇到的问题，而Client端渲染，常用的JWT模式，对于token的保存，一般都是保存在localStorage中，而在服务端渲染中，是没有localStorage的定义的</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\"> typeof localStorage === &#39;undefined&#39; // true</code></pre></div>\n<p>既然我们无法从localStorage中获取数据，那么我们只能从Cookie中获取</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">    //after login \n    cookie.save(&#39;token&#39;, token)</code></pre></div>\n<p>在服务端渲染的express应用中，我们要引入 <a href=\"https://github.com/expressjs/cookie-parser\">cookie-parser模块</a></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const express = require(&#39;express&#39;)\nconst cookieParser = require(&#39;cookie-parser&#39;) ;\nconst serverRender = require(&#39;./server.js&#39;)\n\nconst app = express()\n\napp.use(cookieParser())\n\n//other codes  \n\napp.get(&#39;*&#39;, function (req, res, next) {\n    serverRender.default(req, res);\n})\napp.listen(port, function(err) {\n    if (err) {\n        console.error(err)\n    } else {\n        console.info(&quot;==&gt; 🌎  Listening on port %s. Open up http://localhost:%s/ in your browser.&quot;, port, port)\n    }\n})</code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">import React from &#39;react&#39;\nimport { renderToString } from &#39;react-dom/server&#39;\nimport { RouterContext, match, createMemoryHistory } from &#39;react-router&#39;\nimport configureStore from &#39;../store/configureStore&#39;\nimport routes from &#39;../routes&#39;\n\nexport default function render (req, res) {\n  const token = req.cookies[&#39;token&#39;] // get token from req.cookies\n  let initStore = {}\n  if (token &amp;&amp; isExp(token)) { // token 存在并且是有效未超时的\n    initStore = {user: {token: token}}\n  }\n  const history = createMemoryHistory()\n  const store = configureStore(initStore, history)\n\n  match({routes: routes(store), location: req.url}, (error, redirectLocation, renderProps) =&gt; {\n    // other codes \n  })\n\n}</code></pre></div>\n<p>上述代码中关键的部分就是express应用中使用cookie-parse模块把cookie放到req.cookies中，在请求中再从req.cookies中获取token，\n这时候校验token是否有效。有效则把token存放到初始的store中</p>\n<p>下一步则是在路由中添加登录验证钩子</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">import React from &#39;react&#39;\nimport { Route, IndexRoute } from &#39;react-router&#39;\nimport { redirectToLogin, redirectToBack,isExp } from &#39;./utils/userUtils&#39;\nimport { isClient } from &#39;./utils&#39;\nimport App from &#39;./containers/App&#39;\nimport Login from &#39;./views/login&#39;\nimport Index from &#39;./views/Index&#39;\nimport NotFound from &#39;./components/NotFound&#39;\nimport Mine from &#39;./views/Mine&#39;\n\nexport default (store) =&gt; {\n\n  const serverRequireAuth = (nextState, replace) =&gt; {\n\n    const {user: {token}} = store.getState()\n    if (!token || !isExp(token)) {\n      replace(&#39;/login&#39;)\n    }\n  }\n\n  const serverRedirectAuth = (nextState, replace) =&gt; {\n    const {user: {token}} = store.getState()\n    if (token &amp;&amp; isExp(token)) {\n      replace(&#39;/&#39;)\n    }\n  }\n  //客户端渲染和服务端渲染的校验方式可能会不同\n  const requireAuth = isClient() ? redirectToLogin : serverRequireAuth\n  const redirectAuth = isClient() ? redirectToBack : serverRedirectAuth\n\n  return (\n    &lt;Route path=&quot;/&quot; component={App}&gt;\n      &lt;IndexRoute component={Index}/&gt;\n      &lt;Route path=&quot;/login&quot; component={Login} onEnter={redirectAuth}/&gt;\n      &lt;Route path=&quot;mine&quot; component={Mine} onEnter={requireAuth}/&gt;\n      &lt;Route path=&quot;*&quot; component={NotFound}/&gt;\n    &lt;/Route&gt;\n  )\n}</code></pre></div>\n<p>客户端判断登录状态的函数</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">import jwtDecode from &#39;jwt-decode&#39;\nimport moment from &#39;moment&#39;\nimport { getCookie, setCookie, removeCookie} from &#39;./authService&#39;\n\nconst getInfoFromToken = (token) =&gt; {\n  return jwtDecode(token)\n}\n\nfunction checkTokenExpDiff (token) {\n  let tokenPayload = getInfoFromToken(token)\n  let expiry = moment.unix(tokenPayload.exp)\n  return expiry.diff(moment(), &#39;seconds&#39;)\n}\n/**\n * 是否登录\n * token 存在，并且有效期 &gt; 0秒\n * @returns {boolean} 已经登录返回true，否则返回false\n */\nconst isLogin = function () {\n  const apiToken = getCookie(&#39;token&#39;)\n  return apiToken &amp;&amp; isExp(apiToken)\n}\n/**\n *\n * @param apiToken\n * @return {boolean} token有效返回true，否则返回false\n */\nconst isExp = function (apiToken) {\n  return checkTokenExpDiff(apiToken) &gt; 0\n}\n\n\nconst redirectToBack = (nextState, replace) =&gt; {\n  //已经登录则不进入\n  if (isLogin()) {\n    replace(&#39;/&#39;)\n  }\n}\nconst redirectToLogin = (nextState, replace) =&gt; {\n  if (!isLogin()) {\n    replace(&#39;/login&#39;)\n  }\n}\n\nexport {\n  redirectToLogin,\n  redirectToBack,\n}</code></pre></div>","frontmatter":{"title":"React服务端渲染如何读取登录状态","date":"May 06, 2015","description":null}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/react-ssr-auth/","previous":{"fields":{"slug":"/eslint-get-started/ESLint的使用/"},"frontmatter":{"title":"ESLint的使用"}},"next":{"fields":{"slug":"/new-beginnings/"},"frontmatter":{"title":"New Beginnings"}}}}}